---
title:  "When the world one model is not enough. Stacking models with {stacks}"
description: |
  A few notes on stacking models with {stacks}. 
author:
  - name: Harry Fisher
    url: https://hfshr.xyz
date: 11-15-2020
categories:
  - R
  - Machine learning
output:
  distill::distill_article:
    self_contained: false
draft: true
---


```{r include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(stacks)
```

Models can sometimes make bad predictions. This is no fault of their own of course, as they can only do what they have been trained to do. _Stacking_ models can help to improve any single models performance by combining the strengths of different models into one model stack. This model stack allows the strengths of multiple models to be combined and will _hopefully_ make better predictions. A model stack or ensymbol is obviously not a new technique, but the package `stacks` a fairly recent development allowing model stacking to be achieved within the tidymodels ideology. Apart from having a great hex logo, `stacks` was good fun to use, and I've 

<aside>
```{r out.width="20%"}
knitr::include_graphics("logo.png")
```
</aside>

# The data 

The data I am going to use here comes from chapter 10 of Kuhn and Johnson's Applied Predictive Modelling, and concerns different mixtures of concrete. 

```{r message=FALSE, warning=FALSE}
library(modeldata)
library(tidyverse)
library(tidymodels)
library(vip)
library(stacks)
library(rules)

data("concrete")
skimr::skim(concrete)
```



Lets have a quick look a the relationship between each of the predictor variables and compressive strength:

```{r}
concrete %>% 
  pivot_longer(-compressive_strength) %>% 
  ggplot(aes(x = value, y = compressive_strength)) +
  geom_point() + 
  geom_smooth() +
  facet_wrap(~name, scales = "free_x") +
  theme_minimal()
```


I'm going to assume some experience with using the tidymodels workflow for modelling to avoid this post become too lengthy. For an introduction to tidymodels, I have a post [here]() which covers some of the basics, or you can check out some of the excellent tutorials available on the tidydmodels site [here](https://www.tidymodels.org/learn/).


# Data prep

```{r}
set.seed(1)
concrete_split <- initial_split(concrete)
concrete_train <- training(concrete_split)
concrete_test  <- testing(concrete_split)

# the folds used in tuning steps
folds <- rsample::vfold_cv(concrete_train, v = 5)

# basic recipe used in all models
concrete_rec <- recipe(compressive_strength ~ ., 
                       data = concrete_train)

# metric for evaluation
metric <- metric_set(rmse, rsq)

```


```{r}
set.seed(123)

# protect your eyes!
options(tidymodels.dark = TRUE) 

# convenience function 
ctrl_grid <- control_stack_grid()

# Basic workflow
cement_wf <- 
  workflow() %>% 
  add_recipe(concrete_rec)

# random forest
rf_spec <- 
  rand_forest(
    mtry = tune(),
    min_n = tune(),
    trees = 500
  ) %>%
  set_mode("regression") %>%
  set_engine("ranger")

rf_wflow <-
  cement_wf %>%
  add_model(rf_spec)

rf_res <- 
  tune_grid(
    object = rf_wflow, 
    resamples = folds, 
    grid = 10,
    control = ctrl_grid
  )

# neural net

nnet_spec <-
  mlp(hidden_units = tune(), 
      penalty = tune(), 
      epochs = tune()) %>%
  set_mode("regression") %>%
  set_engine("nnet")

nnet_rec <- 
  concrete_rec %>% 
  step_corr(all_predictors()) %>%
  step_normalize(all_predictors())

nnet_wflow <- 
  cement_wf %>%
  add_model(nnet_spec) %>% 
  update_recipe(nnet_rec)

nnet_res <-
  tune_grid(
    object = nnet_wflow, 
    resamples = folds, 
    grid = 10,
    control = ctrl_grid
  )

# Cubist 
cubist_spec <- 
  cubist_rules(committees = tune(),
               neighbors = tune(),
               max_rules = tune())

cubist_wflow <- 
  cement_wf %>%
  add_model(cubist_spec)

cubist_res <-
  tune_grid(
    object = cubist_wflow, 
    resamples = folds, 
    grid = 10,
    control = ctrl_grid
  )
```

So at this point we have fitted 30 models, 10 models for each type (random forest, neural net and cubist). We can do a quick check of how well each of these models performed. For conviencece, I've created a simple function called `finaliser` that selects the best model, updates the workflow, fits the final model with the best parameters and pulls out the metrics.

```{r}
finaliser <- function(tuned, wkflow, split){
  
  best_mod <- tuned %>%
  select_best("rmse")
  
  final_wf <- wkflow %>% 
  finalize_workflow(best_mod)
  
 final_fit <- 
  final_wf %>%
  last_fit(split) 
 
 final_fit %>%
  collect_metrics()
  
}



bind_rows(
  finaliser(cubist_res, cubist_wflow, concrete_split) %>% mutate(model = "cubist"),
  finaliser(nnet_res, nnet_wflow, concrete_split) %>% mutate(model = "nnet"),
  finaliser(rf_res, rf_wflow, concrete_split) %>% mutate(model = "rf")
) %>% 
  select(model, .metric, .estimate) %>% 
  pivot_wider(names_from = .metric, values_from = .estimate) %>% 
  arrange(rmse)



```

# Time to stack

Now we can start stacking. 

```{r}
cement_st <- 
  # initialize the stack
  stacks() %>%
  # add candidate members
  add_candidates(rf_res) %>%
  add_candidates(nnet_res)  %>% 
  add_candidates(cubist_res) %>% 
  # blend
  blend_predictions() %>% 
  #fit
  fit_members()

cement_st

autoplot(cement_st, type = "weights")
```


```{r}
cement_pred <- predict(cement_st, concrete_test) %>% 
  bind_cols(concrete_test)

```

```{r}
ggplot(cement_pred) +
  aes(x = compressive_strength, 
      y = .pred) +
  geom_point()+ 
  coord_obs_pred() +
  labs(x = "Observed", y = "Predicted")
```



```{r}
member_preds <- predict(cement_st, concrete_test, members = TRUE) %>% 
  bind_cols(., concrete_test %>% 
              select(compressive_strength)) %>% 
  select(compressive_strength, .pred, everything())

```

```{r}
map_dfr(member_preds, ~rmse(.x, truth = compressive_strength, data = member_preds), .id = "model") %>%
  arrange(.estimate) %>% 
  select(model, rmse = .estimate) %>% 
  left_join(., 
            map_dfr(member_preds, ~rsq(.x, truth = compressive_strength, data = member_preds), .id = "model") %>% 
              select(model, rsq = .estimate), "model")



  
```





